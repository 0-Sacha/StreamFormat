#pragma once

#include "ProjectCore/Core/Core.h"

#include <concepts>
#include <limits>

namespace ProjectCore::FMT::Detail
{
    using DataType                                             = std::int32_t;
    static inline constexpr DataType FORMAT_DATA_NOT_SPECIFIED = (std::numeric_limits<DataType>::max)();

    struct FormatIndex
    {
    public:
        using BaseType = std::int32_t;

    public:
        static inline constexpr DataType FORMAT_INDEX_NOT_SET = -1;

    public:
        explicit constexpr FormatIndex(const BaseType index = FORMAT_INDEX_NOT_SET)
            : Index(index)
            , MaxValue((std::numeric_limits<BaseType>::max)())
        {}

        constexpr FormatIndex(const BaseType index, const BaseType maxValue)
            : Index(index)
            , MaxValue(maxValue)
        {}

    public:
        BaseType Index;
        BaseType MaxValue;

    public:
        constexpr bool IsValid() const { return Index >= 0 && Index < MaxValue; }
        constexpr bool Is0() const { return Index == 0; }

    public:
        constexpr FormatIndex& Next()
        {
            ++Index;
            return *this;
        }
        constexpr FormatIndex& Prev()
        {
            --Index;
            return *this;
        }

        constexpr FormatIndex Get() const { return *this; }
        constexpr FormatIndex GetAndNext()
        {
            FormatIndex old = *this;
            ++Index;
            return old;
        }
        constexpr FormatIndex NextAndGet()
        {
            ++Index;
            return *this;
        }
        constexpr FormatIndex GetNext() const
        {
            FormatIndex res = *this;
            ++res.Index;
            return res;
        }

        constexpr FormatIndex GetAndPrev()
        {
            FormatIndex old = *this;
            --Index;
            return old;
        }
        constexpr FormatIndex PrevAndGet()
        {
            --Index;
            return *this;
        }
        constexpr FormatIndex GetPrev() const
        {
            FormatIndex res = *this;
            --res.Index;
            return res;
        }

        constexpr void SetContext(FormatIndex sameContext) { MaxValue = sameContext.MaxValue; }
    };

    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    struct BasicCustomDataType;

    template <typename From, typename To>
    concept EqualOperator = requires(const From& from, To& to)
    {
        to = from;
    };
    template <typename From, typename To>
    concept AddEqualOperator = requires(const From& from, To& to)
    {
        to += from;
    };
    template <typename From, typename To>
    concept MinusEqualOperator = requires(const From& from, To& to)
    {
        to -= from;
    };
    template <typename From, typename To>
    concept MultEqualOperator = requires(const From& from, To& to)
    {
        to *= from;
    };
    template <typename From, typename To>
    concept DivEqualOperator = requires(const From& from, To& to)
    {
        to /= from;
    };
    template <typename From, typename To>
    concept IsEqualOperator = requires(const From& from, const To& to)
    {
        to == from;
    };
    template <typename From, typename To>
    concept NotIsEqualOperator = requires(const From& from, const To& to)
    {
        to != from;
    };
    template <typename From, typename To>
    concept LessThanOperator = requires(const From& from, const To& to)
    {
        to < from;
    };
    template <typename From, typename To>
    concept LessEqualOperator = requires(const From& from, const To& to)
    {
        to <= from;
    };
    template <typename From, typename To>
    concept GreaterThanOperator = requires(const From& from, const To& to)
    {
        to > from;
    };
    template <typename From, typename To>
    concept GreaterEqualOperator = requires(const From& from, const To& to)
    {
        to >= from;
    };
    template <typename From, typename To>
    concept AddOperator = requires(const From& from, const To& to)
    {
        to + from;
    };
    template <typename From, typename To>
    concept MinusOperator = requires(const From& from, const To& to)
    {
        to - from;
    };
    template <typename From, typename To>
    concept MultOperator = requires(const From& from, const To& to)
    {
        to* from;
    };
    template <typename From, typename To>
    concept DivOperator = requires(const From& from, const To& to)
    {
        to / from;
    };

    template <typename From, typename To>
    concept DataTypeEqualOperator = requires(const From& from, To& to)
    {
        requires EqualOperator<From, To>
        == false;
        to = from.Value;
    };
    template <typename From, typename To>
    concept DataTypeAddEqualOperator = requires(const From& from, To& to)
    {
        requires AddEqualOperator<From, To>
        == false;
        to += from.Value;
    };
    template <typename From, typename To>
    concept DataTypeMinusEqualOperator = requires(const From& from, To& to)
    {
        requires MinusEqualOperator<From, To>
        == false;
        to -= from.Value;
    };
    template <typename From, typename To>
    concept DataTypeMultEqualOperator = requires(const From& from, To& to)
    {
        requires MultEqualOperator<From, To>
        == false;
        to *= from.Value;
    };
    template <typename From, typename To>
    concept DataTypeDivEqualOperator = requires(const From& from, To& to)
    {
        requires DivEqualOperator<From, To>
        == false;
        to /= from.Value;
    };
    template <typename From, typename To>
    concept DataTypeIsEqualOperator = requires(const From& from, const To& to)
    {
        requires IsEqualOperator<From, To>
        == false;
        to == from.Value;
    };
    template <typename From, typename To>
    concept DataTypeNotIsEqualOperator = requires(const From& from, const To& to)
    {
        requires NotIsEqualOperator<From, To>
        == false;
        to != from.Value;
    };
    template <typename From, typename To>
    concept DataTypeLessThanOperator = requires(const From& from, const To& to)
    {
        requires LessThanOperator<From, To>
        == false;
        to < from.Value;
    };
    template <typename From, typename To>
    concept DataTypeLessEqualOperator = requires(const From& from, const To& to)
    {
        requires LessEqualOperator<From, To>
        == false;
        to <= from.Value;
    };
    template <typename From, typename To>
    concept DataTypeGreaterThanOperator = requires(const From& from, const To& to)
    {
        requires GreaterThanOperator<From, To>
        == false;
        to > from.Value;
    };
    template <typename From, typename To>
    concept DataTypeGreaterEqualOperator = requires(const From& from, const To& to)
    {
        requires GreaterEqualOperator<From, To>
        == false;
        to >= from.Value;
    };
    template <typename From, typename To>
    concept DataTypeAddOperator = requires(const From& from, const To& to)
    {
        requires AddOperator<From, To>
        == false;
        to + from.Value;
    };
    template <typename From, typename To>
    concept DataTypeMinusOperator = requires(const From& from, const To& to)
    {
        requires MinusOperator<From, To>
        == false;
        to - from.Value;
    };
    template <typename From, typename To>
    concept DataTypeMultOperator = requires(const From& from, const To& to)
    {
        requires MultOperator<From, To>
        == false;
        to* from.Value;
    };
    template <typename From, typename To>
    concept DataTypeDivOperator = requires(const From& from, const To& to)
    {
        requires DivOperator<From, To>
        == false;
        to / from.Value;
    };

    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    struct BasicCustomDataType
    {
    public:
        using ValueType = T;

    public:
        static constexpr T DEFAULT = DEFAULT_VALUE;
        static constexpr T INVALID = INVALID_VALUE;

    public:
        T Value;

    public:
        inline constexpr BasicCustomDataType(const T value = DEFAULT)
            : Value(value)
        {}

    public:
        inline constexpr bool IsValid() { return Value != INVALID; }
        inline constexpr bool IsDefault() { return Value == DEFAULT; }

    public:
        inline constexpr operator T() const { return Value; }

        template <typename K>
        inline constexpr operator K() const requires std::is_convertible_v<T, K>
        {
            return static_cast<K>(Value);
        }

    public:
        // operator +I
        inline constexpr BasicCustomDataType operator+() const { return BasicCustomDataType(Value); }
        // operator -I
        inline constexpr BasicCustomDataType operator-() const { return BasicCustomDataType(-Value); }

    public:
        // operator ++I
        inline constexpr BasicCustomDataType& operator++()
        {
            ++Value;
            return *this;
        }
        // operator --I
        inline constexpr BasicCustomDataType& operator--()
        {
            --Value;
            return *this;
        }
        // operator I++
        inline constexpr BasicCustomDataType operator++(int)
        {
            BasicCustomDataType res(Value);
            ++Value;
            return res;
        }
        // operator I--
        inline constexpr BasicCustomDataType operator--(int)
        {
            BasicCustomDataType res(Value);
            --Value;
            return res;
        }

    public:
        inline constexpr BasicCustomDataType& operator=(const EqualOperator<T> auto i)
        {
            Value = i;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator+=(const AddEqualOperator<T> auto i)
        {
            Value += i;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator-=(const MinusEqualOperator<T> auto i)
        {
            Value -= i;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator*=(const MultEqualOperator<T> auto i)
        {
            Value *= i;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator/=(const DivEqualOperator<T> auto i)
        {
            Value /= i;
            return *this;
        }

        inline constexpr BasicCustomDataType& operator=(const DataTypeEqualOperator<T> auto i)
        {
            Value = i.Value;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator+=(const DataTypeAddEqualOperator<T> auto i)
        {
            Value += i.Value;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator-=(const DataTypeMinusEqualOperator<T> auto i)
        {
            Value -= i.Value;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator*=(const DataTypeMultEqualOperator<T> auto i)
        {
            Value *= i.Value;
            return *this;
        }
        inline constexpr BasicCustomDataType& operator/=(const DataTypeDivEqualOperator<T> auto i)
        {
            Value /= i.Value;
            return *this;
        }
    };
    // operator +
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator+(const AddOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                      rhs)
    {
        return lhs + rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator+(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                      lhs,
                                    const AddOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value + rhs;
    }
    // operator -
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator-(const MinusOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                        rhs)
    {
        return lhs - rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator-(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                        lhs,
                                    const MinusOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value - rhs;
    }
    // operator *
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator*(const MultOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                       rhs)
    {
        return lhs * rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator*(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                       lhs,
                                    const MultOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value * rhs;
    }
    // operator /
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator/(const DivOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                      rhs)
    {
        return lhs / rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator/(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                      lhs,
                                    const DivOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value / rhs;
    }
    // operator + DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator+(const DataTypeAddOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              rhs)
    {
        return lhs.Value + rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator+(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              lhs,
                                    const DataTypeAddOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value + rhs.Value;
    }
    // operator - DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator-(const DataTypeMinusOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                rhs)
    {
        return lhs.Value - rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator-(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                lhs,
                                    const DataTypeMinusOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value - rhs.Value;
    }
    // operator * DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator*(const DataTypeMultOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                               rhs)
    {
        return lhs.Values * rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator*(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                               lhs,
                                    const DataTypeMultOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value * rhs.Value;
    }
    // operator / DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator/(const DataTypeDivOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              rhs)
    {
        return lhs.Value / rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr auto operator/(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              lhs,
                                    const DataTypeDivOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value / rhs.Value;
    }

    // operator ==
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator==(const IsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                          rhs)
    {
        return lhs == rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator==(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                          lhs,
                                     const IsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value == rhs;
    }
    // operator !=
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator!=(const NotIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                             rhs)
    {
        return lhs != rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator!=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                             lhs,
                                     const NotIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value != rhs;
    }
    // operator <
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<(const LessThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                           rhs)
    {
        return lhs < rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                           lhs,
                                    const LessThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value < rhs;
    }
    // operator >
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>(const GreaterThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              rhs)
    {
        return lhs > rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                              lhs,
                                    const GreaterThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value > rhs;
    }
    // operator <=
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<=(const LessEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                            rhs)
    {
        return lhs <= rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                            lhs,
                                     const LessEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value <= rhs;
    }
    // operator >=
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>=(const GreaterEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                               rhs)
    {
        return lhs >= rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                               lhs,
                                     const GreaterEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value >= rhs;
    }
    // operator == DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator==(const DataTypeIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                  rhs)
    {
        return lhs.Value == rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator==(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                  lhs,
                                     const DataTypeIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value == rhs.Value;
    }
    // operator != DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator!=(const DataTypeNotIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                     rhs)
    {
        return lhs.Value != rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator!=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                     lhs,
                                     const DataTypeNotIsEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value != rhs.Value;
    }
    // operator < DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<(const DataTypeLessThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                   rhs)
    {
        return lhs.Value < rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                   lhs,
                                    const DataTypeLessThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value < rhs.Value;
    }
    // operator > DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>(const DataTypeGreaterThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                    const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                      rhs)
    {
        return lhs.Value > rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                      lhs,
                                    const DataTypeGreaterThanOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value > rhs.Value;
    }
    // operator <= DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<=(const DataTypeLessEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                    rhs)
    {
        return lhs.Value <= rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator<=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                    lhs,
                                     const DataTypeLessEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value <= rhs.Value;
    }
    // operator >= DataType
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>=(const DataTypeGreaterEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto lhs,
                                     const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                       rhs)
    {
        return lhs.Value >= rhs.Value;
    }
    template <typename T, T DEFAULT_VALUE, T INVALID_VALUE>
    inline constexpr bool operator>=(const BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>&                                                       lhs,
                                     const DataTypeGreaterEqualOperator<typename BasicCustomDataType<T, DEFAULT_VALUE, INVALID_VALUE>::ValueType> auto rhs)
    {
        return lhs.Value >= rhs.Value;
    }
}
